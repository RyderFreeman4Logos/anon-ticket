# TODO

## Pending
- [x] **Immediate-1** Bootstrap the Cargo workspace with root `Cargo.toml`, shared lint settings, and stub crates for API, monitor, and domain logic so that future work is cleanly modularized – Tests: add smoke `cargo test --all --all-features`/`cargo clippy --workspace --all-features` CI jobs plus unit tests ensuring each crate compiles with required features – Docs: expand `README.md` with the workspace layout diagram and command matrix, and inline crate-level `//!` docs describing responsibilities – Risks/Deps: selecting crate boundaries too early could cause churn; capture assumptions in `design_docs/` for review.
- [x] **Immediate-2** Establish deterministic environment plumbing (Rust toolchain pin, `.env.example`, sample `config/` secrets flow) and wire up `sha3` + `dotenvy` crates across workspace to keep hashing and configuration consistent – Tests: add config parsing unit tests plus a `cargo test` guard verifying `.env` loading from fixtures – Docs: document environment variables in README tables and annotate `.env.example` – Risks/Deps: ensure secrets are never committed by extending `.gitignore` and adding a pre-commit note.
- [x] **ShortTerm-3** Define the storage abstraction layer (`PaymentStore`, `TokenStore`, `MonitorStateStore`) and deliver the initial SQLite-backed adapter covering migrations and connection pooling – Tests: use `sqlx::test` or TempDir-backed integration tests to exercise CRUD flows and transactional guarantees – Docs: generate module-level docs explaining trait contracts and add migration walkthroughs to README – Risks/Deps: confirm `sqlx` offline data is checked in to keep CI deterministic.
- [x] **ShortTerm-4** Implement the PID validation and token derivation helpers (enforcing 32-char hex + SHA3-256) as a shared domain module to guarantee all components apply identical security checks – Tests: property tests ensuring invalid PIDs are rejected plus unit tests comparing hash outputs to vectors – Docs: add `///` docs with examples and update README security model section – Risks/Deps: highlight entropy requirements to avoid weak client implementations.
- [x] **ShortTerm-5** Build the Actix `POST /api/v1/redeem` endpoint that uses the storage trait for atomic claim updates and emits deterministic service tokens – Tests: request-level integration tests (Actix test server) that cover success, duplicate, and invalid PID paths – Docs: extend API reference in README (request/response schemas) and include tracing annotations in code comments – Risks/Deps: ensure DB transactions roll back on network failures; add error taxonomy upfront.
- [x] **MidTerm-6** Ship the monitor service crate that tails `monero-wallet-rpc`, persists qualifying transfers through the storage trait, and tracks height via `MonitorStateStore` without hardcoded defaults – Tests: async integration tests with mocked RPC responses plus regression tests for resume-from-height – Docs: architecture note in `docs/` describing polling cadence and failure recovery – Risks/Deps: requires RPC endpoint availability; design retry/backoff strategy.
- [x] **MidTerm-7** Introduce the caching/bloom-filter abstraction (trait-based) with an in-memory MVP to screen obvious invalid PIDs before hitting storage, paving the way for moka/Redis implementations – Tests: unit tests covering false-positive bounds and eviction plus integration tests verifying cache bypass falls back to DB – Docs: README section comparing cache strategies and inline notes on tuning false-positive rates – Risks/Deps: guard against cache becoming DoS vector by specifying quotas.
- [x] **MidTerm-8** Provide introspection and revocation APIs (`GET /api/v1/token/{token}`, `POST /api/v1/token/{token}/revoke`) backed by the token store with auditing fields populated – Tests: HTTP integration tests covering active, revoked, and missing tokens along with auth failure permutations – Docs: document operational playbooks for revocation and add OpenAPI snippets – Risks/Deps: define auth story (mTLS or static keys) before exposing endpoints.
- [x] **LongTerm-9** Layer in observability and abuse detection (structured tracing, metrics, abuse score escalation, dashboarding hooks) so production deployments can detect DoS or misuse early – Tests: telemetry snapshot tests plus load-test scripts to validate metrics fidelity – Docs: operations guide covering alert thresholds and tracing conventions – Risks/Deps: depends on earlier API + monitor milestones; coordinate with infra for metrics backend.
- [x] **ShortTerm-10** Add Unix socket support for the public API listener (env-driven `API_UNIX_SOCKET`, auto-clean stale sockets, fallback to TCP bind) – Tests: Actix integration tests exercising socket + TCP modes – Docs: README/.env documenting the behavior and deployment tips – Risks/Deps: file permissions/cleanup errors or SELinux/AppArmor policies blocking socket creation.
- [x] **ShortTerm-11** Introduce an internal-only API listener (dedicated port or Unix socket) for admin/monitoring routes so Tor-exposed endpoints stay minimal – Tests: ensure internal routes reject external traffic and cover dual-listener wiring – Docs: configuration guidance describing how to bind internal interfaces and enforce permissions – Risks/Deps: added config complexity; need to clearly separate auth for internal vs public endpoints.
- [x] **ShortTerm-12** Refactor `anon_ticket_domain` into cohesive modules (`config.rs`, `model/`, `services/`, `storage/traits.rs`) so binaries import narrowly-scoped APIs and doc comments reflect the new boundaries – Tests: rerun existing unit/property suites plus add module-specific doctests documenting the new paths – Docs: update crate-level `//!` docs and README “Workspace Layout” to show internal submodules – Risks/Deps: requires careful move semantics to avoid breaking downstream imports; coordinate with open PRs touching domain helpers.
- [x] **ShortTerm-13** Split the API crate into `handlers/`, `state.rs`, and `application.rs` so HTTP wiring, request handling, and bootstrap logic can evolve independently – Tests: keep current Actix integration tests passing and add handler-level unit tests using `App::new()` scaffolds – Docs: extend README “Redemption API” to mention new module boundaries and note how to embed the server in other binaries – Risks/Deps: heavy file moves may invalidate pending branches; schedule work during low churn windows.
- [x] **MidTerm-14** Decompose the monitor crate into RPC client, ingestion pipeline, and worker loop modules while introducing a trait-based transfer source for easier simulation – Tests: add mocked transfer-source tests plus regression coverage for height advancement/backoff; keep long-running `tokio::test` gated – Docs: produce a short architecture note (and README summary) describing the data flow – Risks/Deps: more traits mean stricter lifetime/Send bounds; ensure reqwest client reuse stays efficient.
- [x] **MidTerm-15** Break `anon_ticket_storage` into per-trait impl files (`payment_store.rs`, `token_store.rs`, `monitor_state_store.rs`, `migration.rs`) and add a thin builder for injecting caching/sharding later – Tests: rerun sqlite/postgres integration tests and add targeted unit tests for the builder defaults – Docs: update README “Storage Layer” to explain the builder plus migration split – Risks/Deps: SeaORM entity paths change, so regenerate docs/tests referencing old modules.
- [x] **ShortTerm-16** Harden domain primitives: remove `AbuseTracker`, adopt `moka` for caching, and enforce 32-byte PIDs – **Context**: Audit found memory leaks in abuse tracking (redundant with negative cache) and lock contention in the handwritten PID cache. **Actions**: 1) Delete `AbuseTracker` to simplify logic and rely on negative caching. 2) Replace `InMemoryPidCache` with `moka` for automatic TTL and lock-free concurrency. 3) Bump `PID_LENGTH` to 64 hex chars (32 bytes) for maximum entropy. 4) Add `.trim()` to required env var parsing. – **Tests**: Property tests for 64-char PIDs, concurrency tests for cache under load. – **Risks/Deps**: Breaking change for clients expecting 32-char PIDs; requires `moka` dependency.
- [x] **ShortTerm-17** Secure `PaymentId` construction and introduce random generation – **Context**: `PaymentId::new` and `From<&str>` allow bypassing validation, violating the type-driven security contract. **Actions**: 1) Make `PaymentId::new` private or restricted (`pub(crate)`). 2) Remove `From<&str>` to prevent infallible conversion from untrusted strings. 3) Implement `TryFrom<String>` for validated parsing. 4) Add `PaymentId::generate()` using `getrandom` (gated for Wasm support) to support client-side creation of high-entropy IDs. – **Tests**: Unit tests confirming `new` is inaccessible publicly (compile-fail) and `generate` produces valid 64-char hex strings. – **Risks/Deps**: Breaking change for all downstream crates instantiating PIDs; requires updating all tests to use `parse` or `generate`.
- [x] **ShortTerm-18** Polish domain internals: add hash separators and verify Wasm compat – **Context**: `derive_service_token` concatenates inputs without separators (theoretical canonicalization risk if lengths vary in future), and `getrandom` needs explicit feature gating for Wasm targets. **Actions**: 1) Insert a separator byte (e.g., `|`) between PID and TXID in `derive_service_token`. 2) Ensure `getrandom` dependency in `Cargo.toml` (or workspace) enables the `js` feature for `wasm32` targets to prevent build failures. – **Tests**: Update `derive_service_token` unit tests to reflect new hash values; verify `cargo build --target wasm32-unknown-unknown` passes (if environment permits) or check feature tree. – **Risks/Deps**: Changes derived token values (breaking for existing DB records if any); requires Wasm toolchain for verification.
- [x] **ShortTerm-19** Purge `dotenvy` dependency in favor of shell-native config – **Context**: Hardcoding `.env` file loading inside the binary is an anti-pattern for production "monolithic fortresses" where env vars are injected by systemd/docker. It adds unnecessary file I/O logic. **Actions**: 1) Remove `dotenvy` from workspace dependencies. 2) Delete `hydrate_env_file` from `domain::config`. 3) Update `load_from_env` methods to rely strictly on `std::env::var`. 4) Document `direnv` or `source .env` workflows for local dev in README. – **Tests**: Verify binaries still boot when env vars are set externally; verify build size reduction (minor). – **Risks/Deps**: Breaks `cargo run` for devs who rely solely on implicit `.env` loading; requires doc update.
- [x] **ShortTerm-20** Harden storage configuration and implementation – **Context**: Audit revealed SQLite is running in default mode (poor concurrency) and `claim_payment` performs redundant lookups. **Actions**: 1) In `SeaOrmStorage::connect`, detect SQLite backend and force `PRAGMA journal_mode=WAL;` + `PRAGMA synchronous=NORMAL;`. 2) Update `migration.rs` to explicitly set `string_len(64)` for PID and Token columns. 3) Optimize `claim_payment` by replacing `update_many` + `find` with raw SQL `UPDATE ... RETURNING *` via `SeaOrm::execute/query_one` to eliminate the second round-trip and lock contention. – **Tests**: Integration tests verifying WAL mode active and `claim_payment` correctness/atomicity. – **Risks/Deps**: Raw SQL bypasses some SeaORM safeguards; relies on SQLite >= 3.35.0 (standard in modern environments).
- [ ] **ShortTerm-21** Refactor internal types to binary (`[u8; 32]`) and storage to BLOBs – **Context**: Using `String` (Hex) to represent PIDs and Tokens wastes 2x memory/storage and CPU cycles. Switching to raw bytes aligns with the "Single-Node Fortress" strategy for maximum density and speed. **Actions**: 1) Change `PaymentId` and `ServiceToken` internals from `String` to `[u8; 32]`. 2) Update `domain` serialization to handle Hex encoding/decoding at the API boundary (Serde). 3) Update `storage` migrations to use `BLOB/BYTEA` instead of `VARCHAR`. 4) Update `storage` mapping logic to read/write bytes directly. – **Tests**: Verify JSON API still accepts/returns Hex strings; verify DB stores raw bytes (inspect sqlite file size); verify hash derivation remains consistent. – **Risks/Deps**: Breaking schema change (incompatible with existing String-based DBs); pervasive refactor across all crates.
- [ ] **ShortTerm-22** Optimize `PaymentStatus` column to `TINYINT` – **Context**: Storing "claimed"/"unclaimed" as `VARCHAR(16)` wastes space (~7-9 bytes vs 1 byte) and IO bandwidth. "Single-Node Fortress" philosophy prioritizes efficiency over raw DB readability. **Actions**: 1) Update `migration.rs` to define `status` as `tiny_integer`. 2) Update `entity.rs` to map `PaymentStatusDb` enum to integers (0=Unclaimed, 1=Claimed). 3) Verify `claim_payment` raw SQL uses integer literals. – **Tests**: Verify schema change via migration tests; verify status transitions persist correctly. – **Risks/Deps**: Breaking schema change; debugging raw DB requires knowing the enum mapping (0/1).

## Plan Summary
Foundational scaffolding, storage correctness, and API/monitor surfaces are in place; recent work hardened the domain layer. Upcoming work focuses on optimizing the storage layer for high-concurrency SQLite (WAL mode, atomic RETURNING queries) and fundamentally refactoring core types (Binary PIDs, TinyInt Status) to maximize performance and memory efficiency.
